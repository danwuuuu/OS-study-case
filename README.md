OS Chosen: Android 8.0 Oreo

I.	Introduction 
Android is an operating system which is based on Linux kernel. Android is mainly used in cell phones and tablets and it is applied by a lot famous companies such as Samsung.  Being as the product from Google, Android is open source OS which provides a lot chances to developers to study it and use it well. In this report, there will be a comprehensive analysis of the latest Android version called Android Oreo.

Structure of Android Oreo is 5 layered which includes system applications, API Framework, library, Hardware Abstraction Layer and Linux Kernel. In API Framework, Android Oreo include rich and scalable View, content providers, resource manager, notification manager and activity manager. The architectural design of the application simplifies the reuse of components. 

Linux is programed by C. The kernel layer in Android Oreo is based on Linux, therefore its kernel programing language is C. In terms the the other parts of system, they are developed in Java and most common application running in Android Oreo is developed by Java as well. Android Ores has10G source code. One character takes one byte, therefore there are more than 10 billion characters. Assume each line applied the standard of 80 characters, the code the Android Oreo operating system has about 100 million lines of code there.
II.	CPU Scheduling
Android Oreo mainly uses priority scheduling algorithm where higher the priority of the process has more allocating CPU time and the lower the priority of the process has less allocated CPU time. Android directly calls the system API set priority, which has three parameters. It is not hard to think the reason of applying priority based scheduling algorithm. When using one APP, this specific App will take the whole screen of your phone, at the same time the CPU in your phone is working so hard for this APP to achieve the effects that users need. This can be understood that at this time, this APP might have highest priority. For the APP runs in background might not take much CPU during the period. 

Android Oreo system has multiple models to optimize the usage of CPU and also improve the user experience of OS. Providing enough supports when there is huge demand, and saving as much as possible energy when no application running.  There are like around 15 models there, such as ‘Ondemand’, ‘interactive’, ‘conservative’, ‘smartass’ , ‘powersave’, etc. To illustrate how do they optimize CPU usage, the following part will introduce ‘Ondemand’ model. ‘Ondemand’ model adjust the CPU frequency according to need. It does not operate the phone when the control at the lowest frequency. Achieve when users slide or enter the application will quickly upgrade to the highest frequency. When phone is idle quickly reduce the frequency.  Battery is always a hot topic, 

In Android Oreo, if CPU could handle well, it will need strong hardware support in order to have a smooth performance which will cost a lot. Although there are a lot phones which use Android operating system are much cheaper than iPhone (whose performance is good but expensive), those phones cannot achieve what Android is really working. Open source gives a lot chances to many devices, but the performance is much different between different hardware on the devices.

III.	 Memory Management
Android Oreo has a great improvement on memory optimization for Android Go configurations. In addition, there are new and strong hardware feature constants which make targeting the distribution of applications easier. In Android system, process memory space uses only virtual memory (logical memory), and the program needs real memory which is physical memory (RAM). When needed, the operating system maps(paging) the requested memory (virtual memory) to RAM during program execution, allowing the process to use physical memory. Memory is an indispensable resource for running processes and has a decisive impact on system performance and stability. In addition, the RAM portion of the operating system used for other purposes, such as video memory, etc. Memory map and memory are controlled by the operating system, therefore there is no need to care too much about its operating process space is the virtual address space cannot be directly manipulated RAM.

When an Android program is started, VM process is started. The system allocates a fixed memory space (16M, 32M). This memory space maps to one of the RAMs area. Then this Android program will run in this space. Java will be the space into Stack memory and Heap heap memory. Stored in the stack reference to the object, the actual data stored in the heap. In the process of running will create the object, if not properly managed memory, such as the timely recovery of invalid space will result in memory leaks, serious words may lead to the use of memory than the system allocates memory, memory overflow OOM(out of memory), causing the program to directly exit.  This problem would need Bitmap to help.

Android application is java which will need a virtual machine. Most android applications are with an independent virtual machine, which is open for each application will be an independent Virtual machine. In fact, and java garbage collection mechanism is similar to the system has a rule to recover memory. Memory scheduling has a threshold, only below this value will be a list of systems to shut down what users do not need. Therefore, this value is set by default to be very small, the old memory would be in a very small number of hovering. In the fact, it does not affect the response speed. Instead, it speeds up the next time you start the app which is a great advantages of android system. 

IV.	 File System and I/O 
All the files, operations and directories from kernel abstract layer is named as Virtual File system which are supported by separate kernel module for every file system.  This module could be dynamically loaded or part of module. There is a huge file system in Android kernel and the main job of it is hiding user information. Android kernel has only the file sys which is relevant on its needed operations. 

In android source code, there are these files such as, system.img, ramdisk.img and userdata.img. Among them, ramdisk.img emulator’s file system. In system.img, there are main packages, library and so on. In userdata.img, there are user data, emulator load these three image files. The system and user data are directly loaded into ramdisk file system system and user data directory. Therefore, it is not hard to have data transfer among those three files and system.

How to get the file system?  Image files are zipped, and can be verified with the file command: file ramdisk.img. The output will not only be image files but also the system folder, user date folder, root folder. Copying the data from system and user folder under the directory of ramdisk, then there is file system there now. It is not the only way to do, it can also be achieved by using the network file system mount android file system. Kernel boot file system init.rc script includes many procedures for file system initialization and loading. In the file system, there still are system directory, general system default application directory, system local program directory and core directory.

V.	Conclusions  
Android system is open source, which provides more chances for developers to developer creative application. Developers source code to fully meet the individual needs of users, in line with personal habits. Having a good performance of android system needs expensive hardware support. But in relatively, cheap price is the advantage makes Android's market share far higher than iOS. Market and performance is always hard to be balanced. Android applications has so many kinds. The third-party organizations provide various Android platform resources and JAVA technology support. The free application resources provided by third-party organizations for the Android system has great advantage in market. Various applications and services also raise a problem which is virus. The security of user information and device safety is not guaranteed. 

